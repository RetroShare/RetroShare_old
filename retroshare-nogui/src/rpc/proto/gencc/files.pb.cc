// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "files.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace rsctrl {
namespace files {

namespace {

const ::google::protobuf::Descriptor* FileTransfer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileTransfer_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestTransferList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestTransferList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseTransferList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseTransferList_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestControlDownload_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestControlDownload_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RequestControlDownload_Action_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ResponseControlDownload_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseControlDownload_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestShareDirList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestShareDirList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseShareDirList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseShareDirList_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ResponseShareDirList_ListType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RequestMsgIds_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ResponseMsgIds_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Direction_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_files_2eproto() {
  protobuf_AddDesc_files_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "files.proto");
  GOOGLE_CHECK(file != NULL);
  FileTransfer_descriptor_ = file->message_type(0);
  static const int FileTransfer_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileTransfer, file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileTransfer, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileTransfer, fraction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileTransfer, rate_kbs_),
  };
  FileTransfer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileTransfer_descriptor_,
      FileTransfer::default_instance_,
      FileTransfer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileTransfer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileTransfer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileTransfer));
  RequestTransferList_descriptor_ = file->message_type(1);
  static const int RequestTransferList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestTransferList, direction_),
  };
  RequestTransferList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RequestTransferList_descriptor_,
      RequestTransferList::default_instance_,
      RequestTransferList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestTransferList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestTransferList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RequestTransferList));
  ResponseTransferList_descriptor_ = file->message_type(2);
  static const int ResponseTransferList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseTransferList, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseTransferList, transfers_),
  };
  ResponseTransferList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResponseTransferList_descriptor_,
      ResponseTransferList::default_instance_,
      ResponseTransferList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseTransferList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseTransferList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResponseTransferList));
  RequestControlDownload_descriptor_ = file->message_type(3);
  static const int RequestControlDownload_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestControlDownload, file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestControlDownload, action_),
  };
  RequestControlDownload_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RequestControlDownload_descriptor_,
      RequestControlDownload::default_instance_,
      RequestControlDownload_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestControlDownload, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestControlDownload, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RequestControlDownload));
  RequestControlDownload_Action_descriptor_ = RequestControlDownload_descriptor_->enum_type(0);
  ResponseControlDownload_descriptor_ = file->message_type(4);
  static const int ResponseControlDownload_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseControlDownload, status_),
  };
  ResponseControlDownload_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResponseControlDownload_descriptor_,
      ResponseControlDownload::default_instance_,
      ResponseControlDownload_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseControlDownload, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseControlDownload, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResponseControlDownload));
  RequestShareDirList_descriptor_ = file->message_type(5);
  static const int RequestShareDirList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestShareDirList, ssl_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestShareDirList, path_),
  };
  RequestShareDirList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RequestShareDirList_descriptor_,
      RequestShareDirList::default_instance_,
      RequestShareDirList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestShareDirList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestShareDirList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RequestShareDirList));
  ResponseShareDirList_descriptor_ = file->message_type(6);
  static const int ResponseShareDirList_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseShareDirList, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseShareDirList, ssl_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseShareDirList, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseShareDirList, list_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseShareDirList, files_),
  };
  ResponseShareDirList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResponseShareDirList_descriptor_,
      ResponseShareDirList::default_instance_,
      ResponseShareDirList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseShareDirList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseShareDirList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResponseShareDirList));
  ResponseShareDirList_ListType_descriptor_ = ResponseShareDirList_descriptor_->enum_type(0);
  RequestMsgIds_descriptor_ = file->enum_type(0);
  ResponseMsgIds_descriptor_ = file->enum_type(1);
  Direction_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_files_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileTransfer_descriptor_, &FileTransfer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RequestTransferList_descriptor_, &RequestTransferList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResponseTransferList_descriptor_, &ResponseTransferList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RequestControlDownload_descriptor_, &RequestControlDownload::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResponseControlDownload_descriptor_, &ResponseControlDownload::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RequestShareDirList_descriptor_, &RequestShareDirList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResponseShareDirList_descriptor_, &ResponseShareDirList::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_files_2eproto() {
  delete FileTransfer::default_instance_;
  delete FileTransfer_reflection_;
  delete RequestTransferList::default_instance_;
  delete RequestTransferList_reflection_;
  delete ResponseTransferList::default_instance_;
  delete ResponseTransferList_reflection_;
  delete RequestControlDownload::default_instance_;
  delete RequestControlDownload_reflection_;
  delete ResponseControlDownload::default_instance_;
  delete ResponseControlDownload_reflection_;
  delete RequestShareDirList::default_instance_;
  delete RequestShareDirList_reflection_;
  delete ResponseShareDirList::default_instance_;
  delete ResponseShareDirList_reflection_;
}

void protobuf_AddDesc_files_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::rsctrl::core::protobuf_AddDesc_core_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013files.proto\022\014rsctrl.files\032\ncore.proto\""
    "\177\n\014FileTransfer\022\037\n\004file\030\001 \002(\0132\021.rsctrl.c"
    "ore.File\022*\n\tdirection\030\002 \002(\0162\027.rsctrl.fil"
    "es.Direction\022\020\n\010fraction\030\003 \002(\002\022\020\n\010rate_k"
    "Bs\030\004 \002(\002\"A\n\023RequestTransferList\022*\n\tdirec"
    "tion\030\001 \002(\0162\027.rsctrl.files.Direction\"j\n\024R"
    "esponseTransferList\022#\n\006status\030\001 \002(\0132\023.rs"
    "ctrl.core.Status\022-\n\ttransfers\030\002 \003(\0132\032.rs"
    "ctrl.files.FileTransfer\"\204\002\n\026RequestContr"
    "olDownload\022\037\n\004file\030\001 \002(\0132\021.rsctrl.core.F"
    "ile\022;\n\006action\030\002 \002(\0162+.rsctrl.files.Reque"
    "stControlDownload.Action\"\213\001\n\006Action\022\020\n\014A"
    "CTION_START\020\001\022\023\n\017ACTION_CONTINUE\020\002\022\017\n\013AC"
    "TION_WAIT\020\003\022\020\n\014ACTION_PAUSE\020\004\022\022\n\016ACTION_"
    "RESTART\020\005\022\020\n\014ACTION_CHECK\020\006\022\021\n\rACTION_CA"
    "NCEL\020\007\">\n\027ResponseControlDownload\022#\n\006sta"
    "tus\030\001 \002(\0132\023.rsctrl.core.Status\"3\n\023Reques"
    "tShareDirList\022\016\n\006ssl_id\030\001 \002(\t\022\014\n\004path\030\002 "
    "\002(\t\"\224\002\n\024ResponseShareDirList\022#\n\006status\030\001"
    " \002(\0132\023.rsctrl.core.Status\022\016\n\006ssl_id\030\002 \002("
    "\t\022\014\n\004path\030\003 \002(\t\022>\n\tlist_type\030\004 \002(\0162+.rsc"
    "trl.files.ResponseShareDirList.ListType\022"
    " \n\005files\030\005 \003(\0132\021.rsctrl.core.File\"W\n\010Lis"
    "tType\022\021\n\rDIRQUERY_ROOT\020\001\022\023\n\017DIRQUERY_PER"
    "SON\020\002\022\021\n\rDIRQUERY_FILE\020\003\022\020\n\014DIRQUERY_DIR"
    "\020\004*o\n\rRequestMsgIds\022\035\n\031MsgId_RequestTran"
    "sferList\020\001\022 \n\034MsgId_RequestControlDownlo"
    "ad\020\002\022\035\n\031MsgId_RequestShareDirList\020\003*s\n\016R"
    "esponseMsgIds\022\036\n\032MsgId_ResponseTransferL"
    "ist\020\001\022!\n\035MsgId_ResponseControlDownload\020\002"
    "\022\036\n\032MsgId_ResponseShareDirList\020\003*9\n\tDire"
    "ction\022\024\n\020DIRECTION_UPLOAD\020\001\022\026\n\022DIRECTION"
    "_DOWNLOAD\020\002", 1291);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "files.proto", &protobuf_RegisterTypes);
  FileTransfer::default_instance_ = new FileTransfer();
  RequestTransferList::default_instance_ = new RequestTransferList();
  ResponseTransferList::default_instance_ = new ResponseTransferList();
  RequestControlDownload::default_instance_ = new RequestControlDownload();
  ResponseControlDownload::default_instance_ = new ResponseControlDownload();
  RequestShareDirList::default_instance_ = new RequestShareDirList();
  ResponseShareDirList::default_instance_ = new ResponseShareDirList();
  FileTransfer::default_instance_->InitAsDefaultInstance();
  RequestTransferList::default_instance_->InitAsDefaultInstance();
  ResponseTransferList::default_instance_->InitAsDefaultInstance();
  RequestControlDownload::default_instance_->InitAsDefaultInstance();
  ResponseControlDownload::default_instance_->InitAsDefaultInstance();
  RequestShareDirList::default_instance_->InitAsDefaultInstance();
  ResponseShareDirList::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_files_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_files_2eproto {
  StaticDescriptorInitializer_files_2eproto() {
    protobuf_AddDesc_files_2eproto();
  }
} static_descriptor_initializer_files_2eproto_;

const ::google::protobuf::EnumDescriptor* RequestMsgIds_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestMsgIds_descriptor_;
}
bool RequestMsgIds_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ResponseMsgIds_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseMsgIds_descriptor_;
}
bool ResponseMsgIds_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Direction_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Direction_descriptor_;
}
bool Direction_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int FileTransfer::kFileFieldNumber;
const int FileTransfer::kDirectionFieldNumber;
const int FileTransfer::kFractionFieldNumber;
const int FileTransfer::kRateKBsFieldNumber;
#endif  // !_MSC_VER

FileTransfer::FileTransfer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileTransfer::InitAsDefaultInstance() {
  file_ = const_cast< ::rsctrl::core::File*>(&::rsctrl::core::File::default_instance());
}

FileTransfer::FileTransfer(const FileTransfer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileTransfer::SharedCtor() {
  _cached_size_ = 0;
  file_ = NULL;
  direction_ = 1;
  fraction_ = 0;
  rate_kbs_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileTransfer::~FileTransfer() {
  SharedDtor();
}

void FileTransfer::SharedDtor() {
  if (this != default_instance_) {
    delete file_;
  }
}

void FileTransfer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileTransfer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileTransfer_descriptor_;
}

const FileTransfer& FileTransfer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_files_2eproto();  return *default_instance_;
}

FileTransfer* FileTransfer::default_instance_ = NULL;

FileTransfer* FileTransfer::New() const {
  return new FileTransfer;
}

void FileTransfer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_file()) {
      if (file_ != NULL) file_->::rsctrl::core::File::Clear();
    }
    direction_ = 1;
    fraction_ = 0;
    rate_kbs_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileTransfer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .rsctrl.core.File file = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_direction;
        break;
      }
      
      // required .rsctrl.files.Direction direction = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_direction:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (rsctrl::files::Direction_IsValid(value)) {
            set_direction(static_cast< rsctrl::files::Direction >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_fraction;
        break;
      }
      
      // required float fraction = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fraction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fraction_)));
          set_has_fraction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_rate_kBs;
        break;
      }
      
      // required float rate_kBs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rate_kBs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rate_kbs_)));
          set_has_rate_kbs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileTransfer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .rsctrl.core.File file = 1;
  if (has_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->file(), output);
  }
  
  // required .rsctrl.files.Direction direction = 2;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }
  
  // required float fraction = 3;
  if (has_fraction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->fraction(), output);
  }
  
  // required float rate_kBs = 4;
  if (has_rate_kbs()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->rate_kbs(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileTransfer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .rsctrl.core.File file = 1;
  if (has_file()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->file(), target);
  }
  
  // required .rsctrl.files.Direction direction = 2;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->direction(), target);
  }
  
  // required float fraction = 3;
  if (has_fraction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->fraction(), target);
  }
  
  // required float rate_kBs = 4;
  if (has_rate_kbs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->rate_kbs(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileTransfer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .rsctrl.core.File file = 1;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->file());
    }
    
    // required .rsctrl.files.Direction direction = 2;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }
    
    // required float fraction = 3;
    if (has_fraction()) {
      total_size += 1 + 4;
    }
    
    // required float rate_kBs = 4;
    if (has_rate_kbs()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileTransfer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileTransfer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileTransfer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileTransfer::MergeFrom(const FileTransfer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_file()) {
      mutable_file()->::rsctrl::core::File::MergeFrom(from.file());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
    if (from.has_fraction()) {
      set_fraction(from.fraction());
    }
    if (from.has_rate_kbs()) {
      set_rate_kbs(from.rate_kbs());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileTransfer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileTransfer::CopyFrom(const FileTransfer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileTransfer::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_file()) {
    if (!this->file().IsInitialized()) return false;
  }
  return true;
}

void FileTransfer::Swap(FileTransfer* other) {
  if (other != this) {
    std::swap(file_, other->file_);
    std::swap(direction_, other->direction_);
    std::swap(fraction_, other->fraction_);
    std::swap(rate_kbs_, other->rate_kbs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileTransfer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileTransfer_descriptor_;
  metadata.reflection = FileTransfer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RequestTransferList::kDirectionFieldNumber;
#endif  // !_MSC_VER

RequestTransferList::RequestTransferList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RequestTransferList::InitAsDefaultInstance() {
}

RequestTransferList::RequestTransferList(const RequestTransferList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RequestTransferList::SharedCtor() {
  _cached_size_ = 0;
  direction_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestTransferList::~RequestTransferList() {
  SharedDtor();
}

void RequestTransferList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RequestTransferList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestTransferList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestTransferList_descriptor_;
}

const RequestTransferList& RequestTransferList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_files_2eproto();  return *default_instance_;
}

RequestTransferList* RequestTransferList::default_instance_ = NULL;

RequestTransferList* RequestTransferList::New() const {
  return new RequestTransferList;
}

void RequestTransferList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    direction_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RequestTransferList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .rsctrl.files.Direction direction = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (rsctrl::files::Direction_IsValid(value)) {
            set_direction(static_cast< rsctrl::files::Direction >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestTransferList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .rsctrl.files.Direction direction = 1;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->direction(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RequestTransferList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .rsctrl.files.Direction direction = 1;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->direction(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RequestTransferList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .rsctrl.files.Direction direction = 1;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestTransferList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RequestTransferList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RequestTransferList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestTransferList::MergeFrom(const RequestTransferList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RequestTransferList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestTransferList::CopyFrom(const RequestTransferList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestTransferList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void RequestTransferList::Swap(RequestTransferList* other) {
  if (other != this) {
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RequestTransferList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestTransferList_descriptor_;
  metadata.reflection = RequestTransferList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseTransferList::kStatusFieldNumber;
const int ResponseTransferList::kTransfersFieldNumber;
#endif  // !_MSC_VER

ResponseTransferList::ResponseTransferList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResponseTransferList::InitAsDefaultInstance() {
  status_ = const_cast< ::rsctrl::core::Status*>(&::rsctrl::core::Status::default_instance());
}

ResponseTransferList::ResponseTransferList(const ResponseTransferList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseTransferList::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseTransferList::~ResponseTransferList() {
  SharedDtor();
}

void ResponseTransferList::SharedDtor() {
  if (this != default_instance_) {
    delete status_;
  }
}

void ResponseTransferList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseTransferList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseTransferList_descriptor_;
}

const ResponseTransferList& ResponseTransferList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_files_2eproto();  return *default_instance_;
}

ResponseTransferList* ResponseTransferList::default_instance_ = NULL;

ResponseTransferList* ResponseTransferList::New() const {
  return new ResponseTransferList;
}

void ResponseTransferList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::rsctrl::core::Status::Clear();
    }
  }
  transfers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResponseTransferList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .rsctrl.core.Status status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_transfers;
        break;
      }
      
      // repeated .rsctrl.files.FileTransfer transfers = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transfers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transfers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_transfers;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseTransferList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .rsctrl.core.Status status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }
  
  // repeated .rsctrl.files.FileTransfer transfers = 2;
  for (int i = 0; i < this->transfers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->transfers(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResponseTransferList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .rsctrl.core.Status status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->status(), target);
  }
  
  // repeated .rsctrl.files.FileTransfer transfers = 2;
  for (int i = 0; i < this->transfers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->transfers(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResponseTransferList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .rsctrl.core.Status status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }
    
  }
  // repeated .rsctrl.files.FileTransfer transfers = 2;
  total_size += 1 * this->transfers_size();
  for (int i = 0; i < this->transfers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transfers(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseTransferList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResponseTransferList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResponseTransferList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseTransferList::MergeFrom(const ResponseTransferList& from) {
  GOOGLE_CHECK_NE(&from, this);
  transfers_.MergeFrom(from.transfers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::rsctrl::core::Status::MergeFrom(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResponseTransferList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseTransferList::CopyFrom(const ResponseTransferList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseTransferList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  for (int i = 0; i < transfers_size(); i++) {
    if (!this->transfers(i).IsInitialized()) return false;
  }
  return true;
}

void ResponseTransferList::Swap(ResponseTransferList* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    transfers_.Swap(&other->transfers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResponseTransferList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseTransferList_descriptor_;
  metadata.reflection = ResponseTransferList_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* RequestControlDownload_Action_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestControlDownload_Action_descriptor_;
}
bool RequestControlDownload_Action_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RequestControlDownload_Action RequestControlDownload::ACTION_START;
const RequestControlDownload_Action RequestControlDownload::ACTION_CONTINUE;
const RequestControlDownload_Action RequestControlDownload::ACTION_WAIT;
const RequestControlDownload_Action RequestControlDownload::ACTION_PAUSE;
const RequestControlDownload_Action RequestControlDownload::ACTION_RESTART;
const RequestControlDownload_Action RequestControlDownload::ACTION_CHECK;
const RequestControlDownload_Action RequestControlDownload::ACTION_CANCEL;
const RequestControlDownload_Action RequestControlDownload::Action_MIN;
const RequestControlDownload_Action RequestControlDownload::Action_MAX;
const int RequestControlDownload::Action_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RequestControlDownload::kFileFieldNumber;
const int RequestControlDownload::kActionFieldNumber;
#endif  // !_MSC_VER

RequestControlDownload::RequestControlDownload()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RequestControlDownload::InitAsDefaultInstance() {
  file_ = const_cast< ::rsctrl::core::File*>(&::rsctrl::core::File::default_instance());
}

RequestControlDownload::RequestControlDownload(const RequestControlDownload& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RequestControlDownload::SharedCtor() {
  _cached_size_ = 0;
  file_ = NULL;
  action_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestControlDownload::~RequestControlDownload() {
  SharedDtor();
}

void RequestControlDownload::SharedDtor() {
  if (this != default_instance_) {
    delete file_;
  }
}

void RequestControlDownload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestControlDownload::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestControlDownload_descriptor_;
}

const RequestControlDownload& RequestControlDownload::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_files_2eproto();  return *default_instance_;
}

RequestControlDownload* RequestControlDownload::default_instance_ = NULL;

RequestControlDownload* RequestControlDownload::New() const {
  return new RequestControlDownload;
}

void RequestControlDownload::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_file()) {
      if (file_ != NULL) file_->::rsctrl::core::File::Clear();
    }
    action_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RequestControlDownload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .rsctrl.core.File file = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_action;
        break;
      }
      
      // required .rsctrl.files.RequestControlDownload.Action action = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::rsctrl::files::RequestControlDownload_Action_IsValid(value)) {
            set_action(static_cast< ::rsctrl::files::RequestControlDownload_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestControlDownload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .rsctrl.core.File file = 1;
  if (has_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->file(), output);
  }
  
  // required .rsctrl.files.RequestControlDownload.Action action = 2;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->action(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RequestControlDownload::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .rsctrl.core.File file = 1;
  if (has_file()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->file(), target);
  }
  
  // required .rsctrl.files.RequestControlDownload.Action action = 2;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->action(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RequestControlDownload::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .rsctrl.core.File file = 1;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->file());
    }
    
    // required .rsctrl.files.RequestControlDownload.Action action = 2;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->action());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestControlDownload::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RequestControlDownload* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RequestControlDownload*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestControlDownload::MergeFrom(const RequestControlDownload& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_file()) {
      mutable_file()->::rsctrl::core::File::MergeFrom(from.file());
    }
    if (from.has_action()) {
      set_action(from.action());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RequestControlDownload::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestControlDownload::CopyFrom(const RequestControlDownload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestControlDownload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_file()) {
    if (!this->file().IsInitialized()) return false;
  }
  return true;
}

void RequestControlDownload::Swap(RequestControlDownload* other) {
  if (other != this) {
    std::swap(file_, other->file_);
    std::swap(action_, other->action_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RequestControlDownload::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestControlDownload_descriptor_;
  metadata.reflection = RequestControlDownload_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseControlDownload::kStatusFieldNumber;
#endif  // !_MSC_VER

ResponseControlDownload::ResponseControlDownload()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResponseControlDownload::InitAsDefaultInstance() {
  status_ = const_cast< ::rsctrl::core::Status*>(&::rsctrl::core::Status::default_instance());
}

ResponseControlDownload::ResponseControlDownload(const ResponseControlDownload& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseControlDownload::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseControlDownload::~ResponseControlDownload() {
  SharedDtor();
}

void ResponseControlDownload::SharedDtor() {
  if (this != default_instance_) {
    delete status_;
  }
}

void ResponseControlDownload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseControlDownload::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseControlDownload_descriptor_;
}

const ResponseControlDownload& ResponseControlDownload::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_files_2eproto();  return *default_instance_;
}

ResponseControlDownload* ResponseControlDownload::default_instance_ = NULL;

ResponseControlDownload* ResponseControlDownload::New() const {
  return new ResponseControlDownload;
}

void ResponseControlDownload::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::rsctrl::core::Status::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResponseControlDownload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .rsctrl.core.Status status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseControlDownload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .rsctrl.core.Status status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResponseControlDownload::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .rsctrl.core.Status status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->status(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResponseControlDownload::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .rsctrl.core.Status status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseControlDownload::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResponseControlDownload* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResponseControlDownload*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseControlDownload::MergeFrom(const ResponseControlDownload& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::rsctrl::core::Status::MergeFrom(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResponseControlDownload::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseControlDownload::CopyFrom(const ResponseControlDownload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseControlDownload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void ResponseControlDownload::Swap(ResponseControlDownload* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResponseControlDownload::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseControlDownload_descriptor_;
  metadata.reflection = ResponseControlDownload_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RequestShareDirList::kSslIdFieldNumber;
const int RequestShareDirList::kPathFieldNumber;
#endif  // !_MSC_VER

RequestShareDirList::RequestShareDirList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RequestShareDirList::InitAsDefaultInstance() {
}

RequestShareDirList::RequestShareDirList(const RequestShareDirList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RequestShareDirList::SharedCtor() {
  _cached_size_ = 0;
  ssl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestShareDirList::~RequestShareDirList() {
  SharedDtor();
}

void RequestShareDirList::SharedDtor() {
  if (ssl_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ssl_id_;
  }
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void RequestShareDirList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestShareDirList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestShareDirList_descriptor_;
}

const RequestShareDirList& RequestShareDirList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_files_2eproto();  return *default_instance_;
}

RequestShareDirList* RequestShareDirList::default_instance_ = NULL;

RequestShareDirList* RequestShareDirList::New() const {
  return new RequestShareDirList;
}

void RequestShareDirList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ssl_id()) {
      if (ssl_id_ != &::google::protobuf::internal::kEmptyString) {
        ssl_id_->clear();
      }
    }
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RequestShareDirList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ssl_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ssl_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ssl_id().data(), this->ssl_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }
      
      // required string path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestShareDirList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string ssl_id = 1;
  if (has_ssl_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ssl_id().data(), this->ssl_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ssl_id(), output);
  }
  
  // required string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->path(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RequestShareDirList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string ssl_id = 1;
  if (has_ssl_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ssl_id().data(), this->ssl_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ssl_id(), target);
  }
  
  // required string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RequestShareDirList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ssl_id = 1;
    if (has_ssl_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ssl_id());
    }
    
    // required string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestShareDirList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RequestShareDirList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RequestShareDirList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestShareDirList::MergeFrom(const RequestShareDirList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ssl_id()) {
      set_ssl_id(from.ssl_id());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RequestShareDirList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestShareDirList::CopyFrom(const RequestShareDirList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestShareDirList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void RequestShareDirList::Swap(RequestShareDirList* other) {
  if (other != this) {
    std::swap(ssl_id_, other->ssl_id_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RequestShareDirList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestShareDirList_descriptor_;
  metadata.reflection = RequestShareDirList_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ResponseShareDirList_ListType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseShareDirList_ListType_descriptor_;
}
bool ResponseShareDirList_ListType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ResponseShareDirList_ListType ResponseShareDirList::DIRQUERY_ROOT;
const ResponseShareDirList_ListType ResponseShareDirList::DIRQUERY_PERSON;
const ResponseShareDirList_ListType ResponseShareDirList::DIRQUERY_FILE;
const ResponseShareDirList_ListType ResponseShareDirList::DIRQUERY_DIR;
const ResponseShareDirList_ListType ResponseShareDirList::ListType_MIN;
const ResponseShareDirList_ListType ResponseShareDirList::ListType_MAX;
const int ResponseShareDirList::ListType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ResponseShareDirList::kStatusFieldNumber;
const int ResponseShareDirList::kSslIdFieldNumber;
const int ResponseShareDirList::kPathFieldNumber;
const int ResponseShareDirList::kListTypeFieldNumber;
const int ResponseShareDirList::kFilesFieldNumber;
#endif  // !_MSC_VER

ResponseShareDirList::ResponseShareDirList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResponseShareDirList::InitAsDefaultInstance() {
  status_ = const_cast< ::rsctrl::core::Status*>(&::rsctrl::core::Status::default_instance());
}

ResponseShareDirList::ResponseShareDirList(const ResponseShareDirList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseShareDirList::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  ssl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  list_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseShareDirList::~ResponseShareDirList() {
  SharedDtor();
}

void ResponseShareDirList::SharedDtor() {
  if (ssl_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ssl_id_;
  }
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (this != default_instance_) {
    delete status_;
  }
}

void ResponseShareDirList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseShareDirList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseShareDirList_descriptor_;
}

const ResponseShareDirList& ResponseShareDirList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_files_2eproto();  return *default_instance_;
}

ResponseShareDirList* ResponseShareDirList::default_instance_ = NULL;

ResponseShareDirList* ResponseShareDirList::New() const {
  return new ResponseShareDirList;
}

void ResponseShareDirList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != NULL) status_->::rsctrl::core::Status::Clear();
    }
    if (has_ssl_id()) {
      if (ssl_id_ != &::google::protobuf::internal::kEmptyString) {
        ssl_id_->clear();
      }
    }
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    list_type_ = 1;
  }
  files_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResponseShareDirList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .rsctrl.core.Status status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ssl_id;
        break;
      }
      
      // required string ssl_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ssl_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ssl_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ssl_id().data(), this->ssl_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_path;
        break;
      }
      
      // required string path = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_list_type;
        break;
      }
      
      // required .rsctrl.files.ResponseShareDirList.ListType list_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_list_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::rsctrl::files::ResponseShareDirList_ListType_IsValid(value)) {
            set_list_type(static_cast< ::rsctrl::files::ResponseShareDirList_ListType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_files;
        break;
      }
      
      // repeated .rsctrl.core.File files = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_files:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_files()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_files;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseShareDirList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .rsctrl.core.Status status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }
  
  // required string ssl_id = 2;
  if (has_ssl_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ssl_id().data(), this->ssl_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->ssl_id(), output);
  }
  
  // required string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->path(), output);
  }
  
  // required .rsctrl.files.ResponseShareDirList.ListType list_type = 4;
  if (has_list_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->list_type(), output);
  }
  
  // repeated .rsctrl.core.File files = 5;
  for (int i = 0; i < this->files_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->files(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResponseShareDirList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .rsctrl.core.Status status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->status(), target);
  }
  
  // required string ssl_id = 2;
  if (has_ssl_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ssl_id().data(), this->ssl_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ssl_id(), target);
  }
  
  // required string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->path(), target);
  }
  
  // required .rsctrl.files.ResponseShareDirList.ListType list_type = 4;
  if (has_list_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->list_type(), target);
  }
  
  // repeated .rsctrl.core.File files = 5;
  for (int i = 0; i < this->files_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->files(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResponseShareDirList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .rsctrl.core.Status status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }
    
    // required string ssl_id = 2;
    if (has_ssl_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ssl_id());
    }
    
    // required string path = 3;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
    // required .rsctrl.files.ResponseShareDirList.ListType list_type = 4;
    if (has_list_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->list_type());
    }
    
  }
  // repeated .rsctrl.core.File files = 5;
  total_size += 1 * this->files_size();
  for (int i = 0; i < this->files_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->files(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseShareDirList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResponseShareDirList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResponseShareDirList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseShareDirList::MergeFrom(const ResponseShareDirList& from) {
  GOOGLE_CHECK_NE(&from, this);
  files_.MergeFrom(from.files_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::rsctrl::core::Status::MergeFrom(from.status());
    }
    if (from.has_ssl_id()) {
      set_ssl_id(from.ssl_id());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_list_type()) {
      set_list_type(from.list_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResponseShareDirList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseShareDirList::CopyFrom(const ResponseShareDirList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseShareDirList::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  for (int i = 0; i < files_size(); i++) {
    if (!this->files(i).IsInitialized()) return false;
  }
  return true;
}

void ResponseShareDirList::Swap(ResponseShareDirList* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(ssl_id_, other->ssl_id_);
    std::swap(path_, other->path_);
    std::swap(list_type_, other->list_type_);
    files_.Swap(&other->files_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResponseShareDirList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseShareDirList_descriptor_;
  metadata.reflection = ResponseShareDirList_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace files
}  // namespace rsctrl

// @@protoc_insertion_point(global_scope)
