// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core.proto

#ifndef PROTOBUF_core_2eproto__INCLUDED
#define PROTOBUF_core_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace rsctrl {
namespace core {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_core_2eproto();
void protobuf_AssignDesc_core_2eproto();
void protobuf_ShutdownFile_core_2eproto();

class Status;
class IpAddr;
class Location;
class Person;
class File;
class Dir;
class SystemStatus;
class Bandwidth;
class BandwidthSet;

enum Status_StatusCode {
  Status_StatusCode_FAILED = 0,
  Status_StatusCode_NO_IMPL_YET = 1,
  Status_StatusCode_INVALID_QUERY = 2,
  Status_StatusCode_PARTIAL_SUCCESS = 3,
  Status_StatusCode_SUCCESS = 4,
  Status_StatusCode_READMSG = 5
};
bool Status_StatusCode_IsValid(int value);
const Status_StatusCode Status_StatusCode_StatusCode_MIN = Status_StatusCode_FAILED;
const Status_StatusCode Status_StatusCode_StatusCode_MAX = Status_StatusCode_READMSG;
const int Status_StatusCode_StatusCode_ARRAYSIZE = Status_StatusCode_StatusCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_StatusCode_descriptor();
inline const ::std::string& Status_StatusCode_Name(Status_StatusCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_StatusCode_descriptor(), value);
}
inline bool Status_StatusCode_Parse(
    const ::std::string& name, Status_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_StatusCode>(
    Status_StatusCode_descriptor(), name, value);
}
enum Location_StateFlags {
  Location_StateFlags_ONLINE = 1,
  Location_StateFlags_CONNECTED = 2,
  Location_StateFlags_UNREACHABLE = 4
};
bool Location_StateFlags_IsValid(int value);
const Location_StateFlags Location_StateFlags_StateFlags_MIN = Location_StateFlags_ONLINE;
const Location_StateFlags Location_StateFlags_StateFlags_MAX = Location_StateFlags_UNREACHABLE;
const int Location_StateFlags_StateFlags_ARRAYSIZE = Location_StateFlags_StateFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* Location_StateFlags_descriptor();
inline const ::std::string& Location_StateFlags_Name(Location_StateFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    Location_StateFlags_descriptor(), value);
}
inline bool Location_StateFlags_Parse(
    const ::std::string& name, Location_StateFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Location_StateFlags>(
    Location_StateFlags_descriptor(), name, value);
}
enum Person_Relationship {
  Person_Relationship_FRIEND = 1,
  Person_Relationship_FRIEND_OF_MANY_FRIENDS = 2,
  Person_Relationship_FRIEND_OF_FRIENDS = 3,
  Person_Relationship_UNKNOWN = 4
};
bool Person_Relationship_IsValid(int value);
const Person_Relationship Person_Relationship_Relationship_MIN = Person_Relationship_FRIEND;
const Person_Relationship Person_Relationship_Relationship_MAX = Person_Relationship_UNKNOWN;
const int Person_Relationship_Relationship_ARRAYSIZE = Person_Relationship_Relationship_MAX + 1;

const ::google::protobuf::EnumDescriptor* Person_Relationship_descriptor();
inline const ::std::string& Person_Relationship_Name(Person_Relationship value) {
  return ::google::protobuf::internal::NameOfEnum(
    Person_Relationship_descriptor(), value);
}
inline bool Person_Relationship_Parse(
    const ::std::string& name, Person_Relationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Person_Relationship>(
    Person_Relationship_descriptor(), name, value);
}
enum SystemStatus_NetCode {
  SystemStatus_NetCode_BAD_UNKNOWN = 0,
  SystemStatus_NetCode_BAD_OFFLINE = 1,
  SystemStatus_NetCode_BAD_NATSYM = 2,
  SystemStatus_NetCode_BAD_NODHT_NAT = 3,
  SystemStatus_NetCode_WARNING_RESTART = 4,
  SystemStatus_NetCode_WARNING_NATTED = 5,
  SystemStatus_NetCode_WARNING_NODHT = 6,
  SystemStatus_NetCode_GOOD = 7,
  SystemStatus_NetCode_ADV_FORWARD = 8
};
bool SystemStatus_NetCode_IsValid(int value);
const SystemStatus_NetCode SystemStatus_NetCode_NetCode_MIN = SystemStatus_NetCode_BAD_UNKNOWN;
const SystemStatus_NetCode SystemStatus_NetCode_NetCode_MAX = SystemStatus_NetCode_ADV_FORWARD;
const int SystemStatus_NetCode_NetCode_ARRAYSIZE = SystemStatus_NetCode_NetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SystemStatus_NetCode_descriptor();
inline const ::std::string& SystemStatus_NetCode_Name(SystemStatus_NetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SystemStatus_NetCode_descriptor(), value);
}
inline bool SystemStatus_NetCode_Parse(
    const ::std::string& name, SystemStatus_NetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SystemStatus_NetCode>(
    SystemStatus_NetCode_descriptor(), name, value);
}
enum ExtensionId {
  CORE = 0
};
bool ExtensionId_IsValid(int value);
const ExtensionId ExtensionId_MIN = CORE;
const ExtensionId ExtensionId_MAX = CORE;
const int ExtensionId_ARRAYSIZE = ExtensionId_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExtensionId_descriptor();
inline const ::std::string& ExtensionId_Name(ExtensionId value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExtensionId_descriptor(), value);
}
inline bool ExtensionId_Parse(
    const ::std::string& name, ExtensionId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExtensionId>(
    ExtensionId_descriptor(), name, value);
}
enum PackageId {
  PEERS = 1,
  SYSTEM = 2,
  CHAT = 3,
  SEARCH = 4,
  FILES = 5,
  GXS = 1000
};
bool PackageId_IsValid(int value);
const PackageId PackageId_MIN = PEERS;
const PackageId PackageId_MAX = GXS;
const int PackageId_ARRAYSIZE = PackageId_MAX + 1;

const ::google::protobuf::EnumDescriptor* PackageId_descriptor();
inline const ::std::string& PackageId_Name(PackageId value) {
  return ::google::protobuf::internal::NameOfEnum(
    PackageId_descriptor(), value);
}
inline bool PackageId_Parse(
    const ::std::string& name, PackageId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PackageId>(
    PackageId_descriptor(), name, value);
}
// ===================================================================

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();
  
  Status(const Status& from);
  
  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();
  
  void Swap(Status* other);
  
  // implements Message ----------------------------------------------
  
  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Status_StatusCode StatusCode;
  static const StatusCode FAILED = Status_StatusCode_FAILED;
  static const StatusCode NO_IMPL_YET = Status_StatusCode_NO_IMPL_YET;
  static const StatusCode INVALID_QUERY = Status_StatusCode_INVALID_QUERY;
  static const StatusCode PARTIAL_SUCCESS = Status_StatusCode_PARTIAL_SUCCESS;
  static const StatusCode SUCCESS = Status_StatusCode_SUCCESS;
  static const StatusCode READMSG = Status_StatusCode_READMSG;
  static inline bool StatusCode_IsValid(int value) {
    return Status_StatusCode_IsValid(value);
  }
  static const StatusCode StatusCode_MIN =
    Status_StatusCode_StatusCode_MIN;
  static const StatusCode StatusCode_MAX =
    Status_StatusCode_StatusCode_MAX;
  static const int StatusCode_ARRAYSIZE =
    Status_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusCode_descriptor() {
    return Status_StatusCode_descriptor();
  }
  static inline const ::std::string& StatusCode_Name(StatusCode value) {
    return Status_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(const ::std::string& name,
      StatusCode* value) {
    return Status_StatusCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .rsctrl.core.Status.StatusCode code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::rsctrl::core::Status_StatusCode code() const;
  inline void set_code(::rsctrl::core::Status_StatusCode value);
  
  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.Status)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  int code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class IpAddr : public ::google::protobuf::Message {
 public:
  IpAddr();
  virtual ~IpAddr();
  
  IpAddr(const IpAddr& from);
  
  inline IpAddr& operator=(const IpAddr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IpAddr& default_instance();
  
  void Swap(IpAddr* other);
  
  // implements Message ----------------------------------------------
  
  IpAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpAddr& from);
  void MergeFrom(const IpAddr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string addr = 1 [default = ""];
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  
  // required uint32 port = 2 [default = 0];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.IpAddr)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* addr_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static IpAddr* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message {
 public:
  Location();
  virtual ~Location();
  
  Location(const Location& from);
  
  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();
  
  void Swap(Location* other);
  
  // implements Message ----------------------------------------------
  
  Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Location_StateFlags StateFlags;
  static const StateFlags ONLINE = Location_StateFlags_ONLINE;
  static const StateFlags CONNECTED = Location_StateFlags_CONNECTED;
  static const StateFlags UNREACHABLE = Location_StateFlags_UNREACHABLE;
  static inline bool StateFlags_IsValid(int value) {
    return Location_StateFlags_IsValid(value);
  }
  static const StateFlags StateFlags_MIN =
    Location_StateFlags_StateFlags_MIN;
  static const StateFlags StateFlags_MAX =
    Location_StateFlags_StateFlags_MAX;
  static const int StateFlags_ARRAYSIZE =
    Location_StateFlags_StateFlags_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StateFlags_descriptor() {
    return Location_StateFlags_descriptor();
  }
  static inline const ::std::string& StateFlags_Name(StateFlags value) {
    return Location_StateFlags_Name(value);
  }
  static inline bool StateFlags_Parse(const ::std::string& name,
      StateFlags* value) {
    return Location_StateFlags_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string ssl_id = 1;
  inline bool has_ssl_id() const;
  inline void clear_ssl_id();
  static const int kSslIdFieldNumber = 1;
  inline const ::std::string& ssl_id() const;
  inline void set_ssl_id(const ::std::string& value);
  inline void set_ssl_id(const char* value);
  inline void set_ssl_id(const char* value, size_t size);
  inline ::std::string* mutable_ssl_id();
  inline ::std::string* release_ssl_id();
  
  // required string location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  
  // required .rsctrl.core.IpAddr localaddr = 3;
  inline bool has_localaddr() const;
  inline void clear_localaddr();
  static const int kLocaladdrFieldNumber = 3;
  inline const ::rsctrl::core::IpAddr& localaddr() const;
  inline ::rsctrl::core::IpAddr* mutable_localaddr();
  inline ::rsctrl::core::IpAddr* release_localaddr();
  
  // required .rsctrl.core.IpAddr extaddr = 4;
  inline bool has_extaddr() const;
  inline void clear_extaddr();
  static const int kExtaddrFieldNumber = 4;
  inline const ::rsctrl::core::IpAddr& extaddr() const;
  inline ::rsctrl::core::IpAddr* mutable_extaddr();
  inline ::rsctrl::core::IpAddr* release_extaddr();
  
  // required uint32 state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.Location)
 private:
  inline void set_has_ssl_id();
  inline void clear_has_ssl_id();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_localaddr();
  inline void clear_has_localaddr();
  inline void set_has_extaddr();
  inline void clear_has_extaddr();
  inline void set_has_state();
  inline void clear_has_state();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ssl_id_;
  ::std::string* location_;
  ::rsctrl::core::IpAddr* localaddr_;
  ::rsctrl::core::IpAddr* extaddr_;
  ::google::protobuf::uint32 state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class Person : public ::google::protobuf::Message {
 public:
  Person();
  virtual ~Person();
  
  Person(const Person& from);
  
  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Person& default_instance();
  
  void Swap(Person* other);
  
  // implements Message ----------------------------------------------
  
  Person* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Person& from);
  void MergeFrom(const Person& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Person_Relationship Relationship;
  static const Relationship FRIEND = Person_Relationship_FRIEND;
  static const Relationship FRIEND_OF_MANY_FRIENDS = Person_Relationship_FRIEND_OF_MANY_FRIENDS;
  static const Relationship FRIEND_OF_FRIENDS = Person_Relationship_FRIEND_OF_FRIENDS;
  static const Relationship UNKNOWN = Person_Relationship_UNKNOWN;
  static inline bool Relationship_IsValid(int value) {
    return Person_Relationship_IsValid(value);
  }
  static const Relationship Relationship_MIN =
    Person_Relationship_Relationship_MIN;
  static const Relationship Relationship_MAX =
    Person_Relationship_Relationship_MAX;
  static const int Relationship_ARRAYSIZE =
    Person_Relationship_Relationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Relationship_descriptor() {
    return Person_Relationship_descriptor();
  }
  static inline const ::std::string& Relationship_Name(Relationship value) {
    return Person_Relationship_Name(value);
  }
  static inline bool Relationship_Parse(const ::std::string& name,
      Relationship* value) {
    return Person_Relationship_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string gpg_id = 1;
  inline bool has_gpg_id() const;
  inline void clear_gpg_id();
  static const int kGpgIdFieldNumber = 1;
  inline const ::std::string& gpg_id() const;
  inline void set_gpg_id(const ::std::string& value);
  inline void set_gpg_id(const char* value);
  inline void set_gpg_id(const char* value, size_t size);
  inline ::std::string* mutable_gpg_id();
  inline ::std::string* release_gpg_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .rsctrl.core.Person.Relationship relation = 3;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 3;
  inline ::rsctrl::core::Person_Relationship relation() const;
  inline void set_relation(::rsctrl::core::Person_Relationship value);
  
  // repeated .rsctrl.core.Location locations = 4;
  inline int locations_size() const;
  inline void clear_locations();
  static const int kLocationsFieldNumber = 4;
  inline const ::rsctrl::core::Location& locations(int index) const;
  inline ::rsctrl::core::Location* mutable_locations(int index);
  inline ::rsctrl::core::Location* add_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Location >&
      locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Location >*
      mutable_locations();
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.Person)
 private:
  inline void set_has_gpg_id();
  inline void clear_has_gpg_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_relation();
  inline void clear_has_relation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gpg_id_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Location > locations_;
  int relation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static Person* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();
  
  File(const File& from);
  
  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();
  
  void Swap(File* other);
  
  // implements Message ----------------------------------------------
  
  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // required uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.File)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* hash_;
  ::google::protobuf::uint64 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Dir : public ::google::protobuf::Message {
 public:
  Dir();
  virtual ~Dir();
  
  Dir(const Dir& from);
  
  inline Dir& operator=(const Dir& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dir& default_instance();
  
  void Swap(Dir* other);
  
  // implements Message ----------------------------------------------
  
  Dir* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Dir& from);
  void MergeFrom(const Dir& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // repeated .rsctrl.core.Dir subdirs = 3;
  inline int subdirs_size() const;
  inline void clear_subdirs();
  static const int kSubdirsFieldNumber = 3;
  inline const ::rsctrl::core::Dir& subdirs(int index) const;
  inline ::rsctrl::core::Dir* mutable_subdirs(int index);
  inline ::rsctrl::core::Dir* add_subdirs();
  inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Dir >&
      subdirs() const;
  inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Dir >*
      mutable_subdirs();
  
  // repeated .rsctrl.core.File files = 4;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 4;
  inline const ::rsctrl::core::File& files(int index) const;
  inline ::rsctrl::core::File* mutable_files(int index);
  inline ::rsctrl::core::File* add_files();
  inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::File >&
      files() const;
  inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::File >*
      mutable_files();
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.Dir)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_path();
  inline void clear_has_path();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Dir > subdirs_;
  ::google::protobuf::RepeatedPtrField< ::rsctrl::core::File > files_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static Dir* default_instance_;
};
// -------------------------------------------------------------------

class SystemStatus : public ::google::protobuf::Message {
 public:
  SystemStatus();
  virtual ~SystemStatus();
  
  SystemStatus(const SystemStatus& from);
  
  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemStatus& default_instance();
  
  void Swap(SystemStatus* other);
  
  // implements Message ----------------------------------------------
  
  SystemStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemStatus& from);
  void MergeFrom(const SystemStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SystemStatus_NetCode NetCode;
  static const NetCode BAD_UNKNOWN = SystemStatus_NetCode_BAD_UNKNOWN;
  static const NetCode BAD_OFFLINE = SystemStatus_NetCode_BAD_OFFLINE;
  static const NetCode BAD_NATSYM = SystemStatus_NetCode_BAD_NATSYM;
  static const NetCode BAD_NODHT_NAT = SystemStatus_NetCode_BAD_NODHT_NAT;
  static const NetCode WARNING_RESTART = SystemStatus_NetCode_WARNING_RESTART;
  static const NetCode WARNING_NATTED = SystemStatus_NetCode_WARNING_NATTED;
  static const NetCode WARNING_NODHT = SystemStatus_NetCode_WARNING_NODHT;
  static const NetCode GOOD = SystemStatus_NetCode_GOOD;
  static const NetCode ADV_FORWARD = SystemStatus_NetCode_ADV_FORWARD;
  static inline bool NetCode_IsValid(int value) {
    return SystemStatus_NetCode_IsValid(value);
  }
  static const NetCode NetCode_MIN =
    SystemStatus_NetCode_NetCode_MIN;
  static const NetCode NetCode_MAX =
    SystemStatus_NetCode_NetCode_MAX;
  static const int NetCode_ARRAYSIZE =
    SystemStatus_NetCode_NetCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NetCode_descriptor() {
    return SystemStatus_NetCode_descriptor();
  }
  static inline const ::std::string& NetCode_Name(NetCode value) {
    return SystemStatus_NetCode_Name(value);
  }
  static inline bool NetCode_Parse(const ::std::string& name,
      NetCode* value) {
    return SystemStatus_NetCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .rsctrl.core.SystemStatus.NetCode net_status = 1;
  inline bool has_net_status() const;
  inline void clear_net_status();
  static const int kNetStatusFieldNumber = 1;
  inline ::rsctrl::core::SystemStatus_NetCode net_status() const;
  inline void set_net_status(::rsctrl::core::SystemStatus_NetCode value);
  
  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.SystemStatus)
 private:
  inline void set_has_net_status();
  inline void clear_has_net_status();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  int net_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static SystemStatus* default_instance_;
};
// -------------------------------------------------------------------

class Bandwidth : public ::google::protobuf::Message {
 public:
  Bandwidth();
  virtual ~Bandwidth();
  
  Bandwidth(const Bandwidth& from);
  
  inline Bandwidth& operator=(const Bandwidth& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bandwidth& default_instance();
  
  void Swap(Bandwidth* other);
  
  // implements Message ----------------------------------------------
  
  Bandwidth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bandwidth& from);
  void MergeFrom(const Bandwidth& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float up = 1;
  inline bool has_up() const;
  inline void clear_up();
  static const int kUpFieldNumber = 1;
  inline float up() const;
  inline void set_up(float value);
  
  // required float down = 2;
  inline bool has_down() const;
  inline void clear_down();
  static const int kDownFieldNumber = 2;
  inline float down() const;
  inline void set_down(float value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.Bandwidth)
 private:
  inline void set_has_up();
  inline void clear_has_up();
  inline void set_has_down();
  inline void clear_has_down();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float up_;
  float down_;
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static Bandwidth* default_instance_;
};
// -------------------------------------------------------------------

class BandwidthSet : public ::google::protobuf::Message {
 public:
  BandwidthSet();
  virtual ~BandwidthSet();
  
  BandwidthSet(const BandwidthSet& from);
  
  inline BandwidthSet& operator=(const BandwidthSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BandwidthSet& default_instance();
  
  void Swap(BandwidthSet* other);
  
  // implements Message ----------------------------------------------
  
  BandwidthSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BandwidthSet& from);
  void MergeFrom(const BandwidthSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rsctrl.core.Bandwidth bandwidths = 1;
  inline int bandwidths_size() const;
  inline void clear_bandwidths();
  static const int kBandwidthsFieldNumber = 1;
  inline const ::rsctrl::core::Bandwidth& bandwidths(int index) const;
  inline ::rsctrl::core::Bandwidth* mutable_bandwidths(int index);
  inline ::rsctrl::core::Bandwidth* add_bandwidths();
  inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Bandwidth >&
      bandwidths() const;
  inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Bandwidth >*
      mutable_bandwidths();
  
  // @@protoc_insertion_point(class_scope:rsctrl.core.BandwidthSet)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Bandwidth > bandwidths_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();
  
  void InitAsDefaultInstance();
  static BandwidthSet* default_instance_;
};
// ===================================================================


// ===================================================================

// Status

// required .rsctrl.core.Status.StatusCode code = 1;
inline bool Status::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::rsctrl::core::Status_StatusCode Status::code() const {
  return static_cast< ::rsctrl::core::Status_StatusCode >(code_);
}
inline void Status::set_code(::rsctrl::core::Status_StatusCode value) {
  GOOGLE_DCHECK(::rsctrl::core::Status_StatusCode_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional string msg = 2;
inline bool Status::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& Status::msg() const {
  return *msg_;
}
inline void Status::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void Status::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void Status::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* Status::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IpAddr

// required string addr = 1 [default = ""];
inline bool IpAddr::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddr::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddr::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddr::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& IpAddr::addr() const {
  return *addr_;
}
inline void IpAddr::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void IpAddr::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void IpAddr::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IpAddr::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* IpAddr::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 port = 2 [default = 0];
inline bool IpAddr::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddr::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpAddr::port() const {
  return port_;
}
inline void IpAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// Location

// required string ssl_id = 1;
inline bool Location::has_ssl_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_ssl_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_ssl_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_ssl_id() {
  if (ssl_id_ != &::google::protobuf::internal::kEmptyString) {
    ssl_id_->clear();
  }
  clear_has_ssl_id();
}
inline const ::std::string& Location::ssl_id() const {
  return *ssl_id_;
}
inline void Location::set_ssl_id(const ::std::string& value) {
  set_has_ssl_id();
  if (ssl_id_ == &::google::protobuf::internal::kEmptyString) {
    ssl_id_ = new ::std::string;
  }
  ssl_id_->assign(value);
}
inline void Location::set_ssl_id(const char* value) {
  set_has_ssl_id();
  if (ssl_id_ == &::google::protobuf::internal::kEmptyString) {
    ssl_id_ = new ::std::string;
  }
  ssl_id_->assign(value);
}
inline void Location::set_ssl_id(const char* value, size_t size) {
  set_has_ssl_id();
  if (ssl_id_ == &::google::protobuf::internal::kEmptyString) {
    ssl_id_ = new ::std::string;
  }
  ssl_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_ssl_id() {
  set_has_ssl_id();
  if (ssl_id_ == &::google::protobuf::internal::kEmptyString) {
    ssl_id_ = new ::std::string;
  }
  return ssl_id_;
}
inline ::std::string* Location::release_ssl_id() {
  clear_has_ssl_id();
  if (ssl_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssl_id_;
    ssl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string location = 2;
inline bool Location::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Location::location() const {
  return *location_;
}
inline void Location::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Location::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void Location::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* Location::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .rsctrl.core.IpAddr localaddr = 3;
inline bool Location::has_localaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location::set_has_localaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location::clear_has_localaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location::clear_localaddr() {
  if (localaddr_ != NULL) localaddr_->::rsctrl::core::IpAddr::Clear();
  clear_has_localaddr();
}
inline const ::rsctrl::core::IpAddr& Location::localaddr() const {
  return localaddr_ != NULL ? *localaddr_ : *default_instance_->localaddr_;
}
inline ::rsctrl::core::IpAddr* Location::mutable_localaddr() {
  set_has_localaddr();
  if (localaddr_ == NULL) localaddr_ = new ::rsctrl::core::IpAddr;
  return localaddr_;
}
inline ::rsctrl::core::IpAddr* Location::release_localaddr() {
  clear_has_localaddr();
  ::rsctrl::core::IpAddr* temp = localaddr_;
  localaddr_ = NULL;
  return temp;
}

// required .rsctrl.core.IpAddr extaddr = 4;
inline bool Location::has_extaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Location::set_has_extaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Location::clear_has_extaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Location::clear_extaddr() {
  if (extaddr_ != NULL) extaddr_->::rsctrl::core::IpAddr::Clear();
  clear_has_extaddr();
}
inline const ::rsctrl::core::IpAddr& Location::extaddr() const {
  return extaddr_ != NULL ? *extaddr_ : *default_instance_->extaddr_;
}
inline ::rsctrl::core::IpAddr* Location::mutable_extaddr() {
  set_has_extaddr();
  if (extaddr_ == NULL) extaddr_ = new ::rsctrl::core::IpAddr;
  return extaddr_;
}
inline ::rsctrl::core::IpAddr* Location::release_extaddr() {
  clear_has_extaddr();
  ::rsctrl::core::IpAddr* temp = extaddr_;
  extaddr_ = NULL;
  return temp;
}

// required uint32 state = 5;
inline bool Location::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Location::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Location::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Location::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 Location::state() const {
  return state_;
}
inline void Location::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// Person

// required string gpg_id = 1;
inline bool Person::has_gpg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Person::set_has_gpg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Person::clear_has_gpg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Person::clear_gpg_id() {
  if (gpg_id_ != &::google::protobuf::internal::kEmptyString) {
    gpg_id_->clear();
  }
  clear_has_gpg_id();
}
inline const ::std::string& Person::gpg_id() const {
  return *gpg_id_;
}
inline void Person::set_gpg_id(const ::std::string& value) {
  set_has_gpg_id();
  if (gpg_id_ == &::google::protobuf::internal::kEmptyString) {
    gpg_id_ = new ::std::string;
  }
  gpg_id_->assign(value);
}
inline void Person::set_gpg_id(const char* value) {
  set_has_gpg_id();
  if (gpg_id_ == &::google::protobuf::internal::kEmptyString) {
    gpg_id_ = new ::std::string;
  }
  gpg_id_->assign(value);
}
inline void Person::set_gpg_id(const char* value, size_t size) {
  set_has_gpg_id();
  if (gpg_id_ == &::google::protobuf::internal::kEmptyString) {
    gpg_id_ = new ::std::string;
  }
  gpg_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Person::mutable_gpg_id() {
  set_has_gpg_id();
  if (gpg_id_ == &::google::protobuf::internal::kEmptyString) {
    gpg_id_ = new ::std::string;
  }
  return gpg_id_;
}
inline ::std::string* Person::release_gpg_id() {
  clear_has_gpg_id();
  if (gpg_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpg_id_;
    gpg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool Person::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Person::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Person::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Person::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Person::name() const {
  return *name_;
}
inline void Person::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Person::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Person::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Person::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Person::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .rsctrl.core.Person.Relationship relation = 3;
inline bool Person::has_relation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Person::set_has_relation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Person::clear_has_relation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Person::clear_relation() {
  relation_ = 1;
  clear_has_relation();
}
inline ::rsctrl::core::Person_Relationship Person::relation() const {
  return static_cast< ::rsctrl::core::Person_Relationship >(relation_);
}
inline void Person::set_relation(::rsctrl::core::Person_Relationship value) {
  GOOGLE_DCHECK(::rsctrl::core::Person_Relationship_IsValid(value));
  set_has_relation();
  relation_ = value;
}

// repeated .rsctrl.core.Location locations = 4;
inline int Person::locations_size() const {
  return locations_.size();
}
inline void Person::clear_locations() {
  locations_.Clear();
}
inline const ::rsctrl::core::Location& Person::locations(int index) const {
  return locations_.Get(index);
}
inline ::rsctrl::core::Location* Person::mutable_locations(int index) {
  return locations_.Mutable(index);
}
inline ::rsctrl::core::Location* Person::add_locations() {
  return locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Location >&
Person::locations() const {
  return locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Location >*
Person::mutable_locations() {
  return &locations_;
}

// -------------------------------------------------------------------

// File

// required string name = 1;
inline bool File::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& File::name() const {
  return *name_;
}
inline void File::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void File::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void File::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* File::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string hash = 2;
inline bool File::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& File::hash() const {
  return *hash_;
}
inline void File::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void File::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void File::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* File::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 size = 3;
inline bool File::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 File::size() const {
  return size_;
}
inline void File::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Dir

// required string name = 1;
inline bool Dir::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Dir::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Dir::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Dir::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Dir::name() const {
  return *name_;
}
inline void Dir::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Dir::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Dir::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Dir::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Dir::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string path = 2;
inline bool Dir::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Dir::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Dir::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Dir::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Dir::path() const {
  return *path_;
}
inline void Dir::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Dir::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Dir::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Dir::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Dir::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .rsctrl.core.Dir subdirs = 3;
inline int Dir::subdirs_size() const {
  return subdirs_.size();
}
inline void Dir::clear_subdirs() {
  subdirs_.Clear();
}
inline const ::rsctrl::core::Dir& Dir::subdirs(int index) const {
  return subdirs_.Get(index);
}
inline ::rsctrl::core::Dir* Dir::mutable_subdirs(int index) {
  return subdirs_.Mutable(index);
}
inline ::rsctrl::core::Dir* Dir::add_subdirs() {
  return subdirs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Dir >&
Dir::subdirs() const {
  return subdirs_;
}
inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Dir >*
Dir::mutable_subdirs() {
  return &subdirs_;
}

// repeated .rsctrl.core.File files = 4;
inline int Dir::files_size() const {
  return files_.size();
}
inline void Dir::clear_files() {
  files_.Clear();
}
inline const ::rsctrl::core::File& Dir::files(int index) const {
  return files_.Get(index);
}
inline ::rsctrl::core::File* Dir::mutable_files(int index) {
  return files_.Mutable(index);
}
inline ::rsctrl::core::File* Dir::add_files() {
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::File >&
Dir::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::File >*
Dir::mutable_files() {
  return &files_;
}

// -------------------------------------------------------------------

// SystemStatus

// required .rsctrl.core.SystemStatus.NetCode net_status = 1;
inline bool SystemStatus::has_net_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemStatus::set_has_net_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemStatus::clear_has_net_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemStatus::clear_net_status() {
  net_status_ = 0;
  clear_has_net_status();
}
inline ::rsctrl::core::SystemStatus_NetCode SystemStatus::net_status() const {
  return static_cast< ::rsctrl::core::SystemStatus_NetCode >(net_status_);
}
inline void SystemStatus::set_net_status(::rsctrl::core::SystemStatus_NetCode value) {
  GOOGLE_DCHECK(::rsctrl::core::SystemStatus_NetCode_IsValid(value));
  set_has_net_status();
  net_status_ = value;
}

// optional string msg = 2;
inline bool SystemStatus::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemStatus::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemStatus::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemStatus::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& SystemStatus::msg() const {
  return *msg_;
}
inline void SystemStatus::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SystemStatus::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SystemStatus::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStatus::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* SystemStatus::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Bandwidth

// required float up = 1;
inline bool Bandwidth::has_up() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bandwidth::set_has_up() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bandwidth::clear_has_up() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bandwidth::clear_up() {
  up_ = 0;
  clear_has_up();
}
inline float Bandwidth::up() const {
  return up_;
}
inline void Bandwidth::set_up(float value) {
  set_has_up();
  up_ = value;
}

// required float down = 2;
inline bool Bandwidth::has_down() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bandwidth::set_has_down() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bandwidth::clear_has_down() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bandwidth::clear_down() {
  down_ = 0;
  clear_has_down();
}
inline float Bandwidth::down() const {
  return down_;
}
inline void Bandwidth::set_down(float value) {
  set_has_down();
  down_ = value;
}

// optional string name = 3;
inline bool Bandwidth::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Bandwidth::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Bandwidth::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Bandwidth::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Bandwidth::name() const {
  return *name_;
}
inline void Bandwidth::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Bandwidth::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Bandwidth::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bandwidth::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Bandwidth::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BandwidthSet

// repeated .rsctrl.core.Bandwidth bandwidths = 1;
inline int BandwidthSet::bandwidths_size() const {
  return bandwidths_.size();
}
inline void BandwidthSet::clear_bandwidths() {
  bandwidths_.Clear();
}
inline const ::rsctrl::core::Bandwidth& BandwidthSet::bandwidths(int index) const {
  return bandwidths_.Get(index);
}
inline ::rsctrl::core::Bandwidth* BandwidthSet::mutable_bandwidths(int index) {
  return bandwidths_.Mutable(index);
}
inline ::rsctrl::core::Bandwidth* BandwidthSet::add_bandwidths() {
  return bandwidths_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Bandwidth >&
BandwidthSet::bandwidths() const {
  return bandwidths_;
}
inline ::google::protobuf::RepeatedPtrField< ::rsctrl::core::Bandwidth >*
BandwidthSet::mutable_bandwidths() {
  return &bandwidths_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace rsctrl

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rsctrl::core::Status_StatusCode>() {
  return ::rsctrl::core::Status_StatusCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rsctrl::core::Location_StateFlags>() {
  return ::rsctrl::core::Location_StateFlags_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rsctrl::core::Person_Relationship>() {
  return ::rsctrl::core::Person_Relationship_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rsctrl::core::SystemStatus_NetCode>() {
  return ::rsctrl::core::SystemStatus_NetCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< rsctrl::core::ExtensionId>() {
  return rsctrl::core::ExtensionId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< rsctrl::core::PackageId>() {
  return rsctrl::core::PackageId_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_core_2eproto__INCLUDED
