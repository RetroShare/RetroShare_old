
This document proposes the finer details of how to communicate with RS, 
using SSH and protobuf classes.
==========================================================================

Message Format
====================

Protobuf serialisation does not identify Message Types or Message Size.
So we need to have an encapsulation header system 

These headers describe the actual message via a MsgId and MsgSize.
Care must be taken to ensure these IDS are correct, as this is NOT enforced
by protobuf, and will lead to incorrect deserialisation!

In Each .proto there is a list of MsgIds as an ENUM.

The protocol message format is as follows: 
	[HEADER: 16 bytes: 4 x Network Order uint32_t][ VARIABLE LENGTH BODY ] 

	[ MAGIC_CODE ] [ MSG_ID ] [ REQ_ID ] [ BODY_SIZE ] [ ..... BODY ..... ]
	MagicCode = 0x137f0001. will be incremented for new versions of the protocol.
 	MsgID = Corresponds to the format of the Body.
	ReqID = Generated by Requester, Returned in Response, 
		make sure its unique. (undefined behaviour for duplicates)
        BodySize = Byte Length of Body.

	The Body will consist of a protobuf encoded message.


Usage
=================
 * Create SSH connection to retroshare-nogui.
 * Create Request Message(s), and send over SSH channel - You can send as meny requests as you want. 
 * They will processed, and responses sent back (potentially in an arbitary order).

MsgIDs
=================
In Each .proto there is a list of MsgIds as an ENUM.

0x00 XX XX xx	=> Reserved for libretroshare Requests. (XX - area, xxxx specific msg)
0x01 XX XX xx	=> Reserved for libretroshare Responses

eg. 0x00 (fa bc) [01] -> Request, 0x01 (fa bc) [01/02/03] -> responses

0x10 YY YY yy   => Extensions for project YY (16k), with sub commands yy (256)
0x11 YY YY yy

... if we run out of YY's will use 0x20 etc.


Extensions
=================

These are welcome and encouraged.
We just need to make sure that MsgIDs don't clash.




